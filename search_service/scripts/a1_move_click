#!/usr/bin/env python
import roslib
import rospy
import actionlib
import controller_manager_msgs.srv
import control_msgs.msg
import trajectory_msgs.msg
import roslib
import math
import sys
import rospy
import actionlib
import trajectory_msgs.msg
import geometry_msgs.msg
from std_msgs.msg import String
from std_msgs.msg import Int8
from nav_msgs.msg import Odometry, Path
from geometry_msgs.msg import PoseStamped, Point, Quaternion, PointStamped
from nav_msgs.srv import GetMultiPlan, GetPlan
from state_lattice_planner.msg import *

class a1_slp_manager(object):
    def __init__(self, wait=0.0):
        # self.waypoints=[]
        self.goals=[]
        self.lastgoal=PoseStamped()
        self.goal=PoseStamped()
        self.gpose=PoseStamped()
        self.gpose.pose.orientation.w=1.0
        self.start_pose=PoseStamped()
        self.start_pose.pose.orientation.w=1.0
        click_topic='clicked_point'
        rospy.Subscriber(click_topic, PointStamped, self.clicked_Cb)
        # pose_topic='global_pose'
        pose_topic='global_pose_a1_121'
        rospy.Subscriber(pose_topic,PoseStamped, self.robot_pose_Cb)
        goal_pose_topic='/search_goal'
        rospy.Subscriber(goal_pose_topic, PoseStamped, self.search_goal_Cb)
        # self.srv_client=rospy.ServiceProxy('/planner/planner/make_multiplan', GetMultiPlan)
        self.srv_client=rospy.ServiceProxy('/planner/planner/make_plan', GetPlan)
        self.client = actionlib.SimpleActionClient('localnavi_server',state_lattice_planner.msg.LocalNaviAction)
        self.tolerance=0.5

    def clicked_Cb(self, msg):
        print(msg)
        pose = PoseStamped()
        pose.header.stamp = rospy.Time.now()
        pose.header.frame_id = "map"
        pose.pose.position= msg.point
        pose.pose.orientation.w=1.0

        rospy.wait_for_service('planner/planner/make_plan')
        ans = self.srv_client(self.start_pose,pose, self.tolerance)
        print("ans.plan", ans.plan)

        self.client.wait_for_server()
        goal = state_lattice_planner.msg.LocalNaviGoal()
        goal.path = ans.plan
        self.client.send_goal(goal)
        # self.client.wait_for_result()

        self.client.wait_for_result(rospy.Duration(15.0))
      
        # self.goalpub.publish(pose)
        # rospy.loginfo("sending new goal to movebase")



    # def pose_Cb(self, goal):
        # rospy.loginfo("goal callback")
    def robot_pose_Cb(self, msg):
        # rospy.loginfo("call back")
        self.gpose=msg
        self.start_pose.header.frame_id='map'
        self.start_pose.pose=msg.pose
    
 
    def search_goal_Cb(self, goal):
        rospy.loginfo("a1---goal--- callback")
        self.goal=goal
        self.goals=[]
        self.goals.append(goal)
        # rospy.wait_for_service('planner/planner/make_multiplan')
        rospy.wait_for_service('planner/planner/make_plan')
        ans = self.srv_client(self.start_pose,self.goal, self.tolerance)

        self.client.wait_for_server()
        goal = state_lattice_planner.msg.LocalNaviGoal()
        goal.path = ans.plan
        self.client.send_goal(goal)
        # self.client.wait_for_result()

        self.client.wait_for_result(rospy.Duration(10.0))
        # goal.header.frame_id="map_en"
        # rospy.sleep(3.0)
        # rpsy.sleep()
        #Should check if the last action is still being executed
        # self.cli.wait_for_server()

    def starter(self,wait=0.0):
        # make sure the cont0roller is running
        # r=rospy.Rate(1)
        rospy.spin()            
        # for waypoint in self.waypoints:
            # self.sendactiongoal(waypoint)
        # fill ROS message
          
if __name__ == '__main__':
    rospy.init_node('move_a1')
    goal_manager = a1_slp_manager()
    goal_manager.starter()



































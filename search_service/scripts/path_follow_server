#!/usr/bin/env python
import roslib
import rospy
import actionlib
import controller_manager_msgs.srv
import control_msgs.msg
import trajectory_msgs.msg
import roslib
import math
import sys
import rospy
import actionlib
import control_msgs.msg
import controller_manager_msgs.srv
import trajectory_msgs.msg
import geometry_msgs.msg
import controller_manager_msgs.srv
from control_msgs.msg import JointTrajectoryControllerState
from move_base_msgs.msg import MoveBaseAction, MoveBaseGoal
from std_msgs.msg import String
from std_msgs.msg import Int8
from nav_msgs.msg import Odometry, Path
from actionlib_msgs.msg import GoalStatus
from geometry_msgs.msg import PoseStamped, Point, Quaternion
from search_service.msg import PathFollowAction, PathFollowFeedback, PathFollowResult
# import tf.transformations

class waypoint_manager(object):
    def __init__(self, name, target_nav_action, target_path_topic, wait=0.0):

        self._action_name = name

        self._as = actionlib.SimpleActionServer(self._action_name, PathFollowAction, execute_cb=self.execute_cb, auto_start = False)
        self.feedback_ = PathFollowFeedback()
        self.result_= PathFollowResult()


        print("target_nav_action: ", target_nav_action)
        print("target_path_topic: ", target_path_topic)
        self.cli = actionlib.SimpleActionClient(target_nav_action, MoveBaseAction)
        self.cli.wait_for_server()
        print("move_base-action-connected")

        # path_topic='agent_1_path'
        rospy.Subscriber(target_path_topic, Path, self.path_Cb)
        self.desired_path = Path()

 
        self._as.start()
        rospy.loginfo("action_started")
        rospy.spin()

    def path_Cb(self, msg):
        print("path_callback")
        self.desired_path = msg

    def execute_cb(self, goal):
        rospy.loginfo("path_follow execute_cb")
        rospy.loginfo("wait_for_move_base")
        self.cli.wait_for_server()
        rospy.loginfo("wait_for_move_base-done")

        movegoal =MoveBaseGoal()
        current_path =self.desired_path
        current_path_size = len(current_path.poses)
        print("current_path_size: ",len(current_path.poses))
        path_skip_const=70

        for pos_idx in range(0, current_path_size,path_skip_const):
            pose = current_path.poses[pos_idx]
            print("pose", pose)
            # movegoal.target_pose.header= goal.header
            movegoal.target_pose= pose
            # rospy.loginfo("sending goal", self.goal)
            self.cli.send_goal(movegoal)
            self.cli.wait_for_result(rospy.Duration(15.0))
            rospy.loginfo("moving to the goal")
            action_state=self.cli.get_state()
            rospy.loginfo(action_state)
            if action_state == GoalStatus.SUCCEEDED:
                rospy.loginfo("Navigation Succeeded = next waypoint")

        rospy.loginfo("Done?")
        self.result_.is_done=True
        self._as.set_succeeded(self.result_)


if __name__ == '__main__':
    rospy.init_node('path_follow_action')
    if len(sys.argv)<3:
        print("usate: path_follow_server arg1(target_movebase_action_topic) arg2(path_topic)")
    else:
        print("arg1: ", sys.argv[1])
        print("arg2: ", sys.argv[2])
        path_manager = waypoint_manager(rospy.get_name(), sys.argv[1], sys.argv[2])


    # path_manager = waypoint_manager(rospy.get_name())
















